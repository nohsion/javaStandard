# javaStandard

Java의 정석 3판 학습노트 정리

<details>
<summary>5. 배열 array</summary>
<div markdown="1">       

## 5. 배열 array

### 1. 배열의 복사

#### 1. for문

      1. 기존 배열 길이 2배
      2. 값 복사

#### 2. System.arraycopy()

      1. 지정된 범위 값들을 한 번에 통째로 복사
      2. 더욱 효율적

### 2. 배열의 활용

#### 1. 총합과 평균

#### 2. 최대값과 최소값

      1. 첫번째 요소로 최대, 최소를 초기화

#### 3. 섞기(shuffle)

      1. 카드섞기
      2. 로또번호 생성
        - 6개 뽑으므로, 인덱스를 0~5까지 반복하면서 임의의 위치에 있는 값과 자리를 바꾼다.
        - 뽑을 때는, 앞에서부터 6개를 뽑으면 된다.(인덱스 0~5)

### 2. String 배열

#### 1. 변경 불가한 객체 (immutable)

      1. '=='가 아닌 equals()로 내용 비교

### 3. 다차원 배열

#### 1. 2차원 배열 선언

      1. int[][] score;
      2. int score[];
      3. int[] score[];
      4. int[][] score = new int[4][3] // 4행 3열

#### 2. 2차원 배열 초기화

      1. int[][] score = new int[][] { {1,2,3}, {4,5,6} };
      2. int[][] score = { {1,2,3}, {4,5,6} }; // new int[][] 생략 가능
      3. int[][] score = {
                            {1,2,3},
                            {4,5,6}
                         };

#### 3. 좌표에 X표 하기

      1. 숫자 1에 문자 '0'을 더하면 문자 '1'이 된다.
      2. println이 1차원 배열을 바로 출력 가능한 경우는, char배열일 때만.

#### 4. 빙고

      1. 2중 반복문 탈출(break 이름 붙이기)
      2. **outer**:
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
                    ...
                    if () break **outer**; // 2중 반복문 탈출 이름붙이기
                }
            }

#### 5. 단어 맞추기

      1. equals()

</div>
</details>

<details>
<summary>6. 객체지향 프로그래밍 Ⅰ 🤩</summary>
<div markdown="1">  

## 6. 객체지향 프로그래밍 (핵심)

### 1. 클래스와 객체

클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아니다. 클래스를 정의하고 객체를 생성할 때는 어떻게 정의할지 고민할 필요가 없다. 그냥 생성만 하면 된다.

#### 1. 객체와 인스턴스

클래스 -> 인스턴스(객체) : 클래스의 인스턴스화. 이때 이 객체를 그 클래스의 인스턴스라고 한다.

#### 2. 객체의 구성요소 - 속성과 기능

객체를 정의한 것이 클래스이므로, 클래스 안에는 객체의 모든 속성과 기능이 정의되어 있다.

- '속성'(property): **'멤버변수'** (member variable, field)
- '기능'(function): **'메서드'** (method)

      class Tv {
            // member
            String color;
            boolean power;
            int channel;

            // method
            void power() { power = !power; }
            void channelUp() { channel++; }
            void channelDown() { channel--; }
            }

#### 3. 인스턴스 생성과 사용

      Tv t = new Tv();
      t.channel = 7;
      t.channelDown();

#### 4. 객체 배열

      Tv[] tvArr = new Tv[3]; // 참조변수 배열 생성
      // 객체를 생성해서 배열의 각 요소에 저장
      for (int i = 0; i < tvArr.length; i++) {
        tvArr[i] = new Tv();
      }

그러면, 여러 종류의 객체를 하나의 배열에 저장하는 방법은 없을까?? -> '다형성 참고'

#### 5. 클래스의 또 다른 정의

객체지향언어에서는 변수와 함수를 하나의 클래스에 정의하여 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있게 했다. 그것이 바로 클래스이다. C에서는 문자열을 문자의 배열로 다루지만, Java에서는
String이라는 클래스로 문자열을 다룬다. 문자열을 클래스로 정의한 이유는 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서이다.

1. user-defined type  
   primitive type 외에 프로그래머가 관련된 변수들을 묶어 하나의 타입으로 새로 만드는 것을 user-defined type이라 한다. 자바에서는 클래스가 곧 사용자 정의 타입이다.

### 2. 변수와 메서드

#### 1. 변수 종류

- 지역변수
    - 멤버변수 제외한 모든 변수 (메서드, 생성자, 초기화 내부)
- 멤버변수
    - 클래스변수 (공유변수) static O
    - 인스턴스 변수 static X

1. 인스턴스 변수  
   인스턴스마다 고유한 상태를 유지해야 하는 경우
2. 클래스 변수  
   모든 인스턴스가 공통된 값을 유지해야 하는 경우. (해당 변수를 공유해서 사용)
3. 지역 변수  
   블럭 내에서만 사용 가능.

#### 2. 메서드를 사용하는 이유

1. 높은 재사용성 (reusability)  
   한 번 만들어 놓은 메소드는 계속 호출 가능하고, 다른 프로그램에서도 사용이 가능하다.
2. 중복 코드 제거  
   같은 문장이 여러 곳에 반복할 경우, 하나로 묶어 메서드로 만들면 한 문장으로 대체 가능하다. 또한, 변경사항이 발생했을 때도 수정할 부분이 줄어든다. 오류 가능성도 낮아진다.
3. 프로그램의 구조화  
   main메서드는 프로그램의 전체 흐름이 한눈에 들어올 정도로 단순하게 구조화하는 것이 좋다. 프로그램 설계 시 내용이 없는 메서드를 작업단위로 만들어 놓고, 하나씩 완성해가는 것도 좋은 방법이다.

   public static void main(Stirng args[]) { // 메인 메서드 예시 int[] numArr = new int[10];

        initArr(numArr);
        printArr(numArr);
        sortArr(numArr);
        printArr(numArr);
   }

#### 3. JVM 메모리 구조

응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

1. Method Area  
   프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스파일(*.class)을 분석하여 클래스 데이터를 이곳에 저장한다. 이때, 그 클래스의 클래스변수도 함께 생성된다.
2. Heap  
   모든 인스턴스가 생성되는 공간.
3. Call Stack (또는 Execution stack)  
   메서드 작업에 필요한 메모리 공간을 제공한다. 메서드가 작업을 마치면 할당된 메모리공간은 반환되면서 비워진다. 따라서, call stack을 조사해보면 메서드 간의 호출관계와 현재 수행중인 메서드가 어느 것인지
   알 수 있다.
    - 메서드가 호출되면 필요한 만큼 메모리를 스택에 할당받는다.
    - 메서드 수행이 끝나면 메모리를 반환하고 스택에서 pop된다.
    - call stack의 가장 위(top)의 메소드가 현재 실행 중인 메서드이다.
    - 아래 메소드가 바로 위의 메서드를 호출한 메서드이다.

=> Ch06 > CallStackTest 참고

#### 4. 기본형 매개변수와 참조형 매개변수

메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다. 타입이 primitive일 때는 기본형 값이 복사되지만, reference이면 인스턴스의 주소가 복사된다. 메서드의 매개변수를
기본형으로 선언하면 단순히 저장된 값만 얻지만(read only), 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 변경하는 것(read & write)도 가능하다.

#### 5. 클래스 메서드(static메서드)와 인스턴스 메서드

인스턴스 메서드는 메서드의 작업을 수행하는데 인스턴스 변수가 필요한 경우. 클래스 메서드는 인스턴스와 관계없는 메서드를 말한다. (인스턴스 변수나 메서드를 사용하지 않는)

1. 클래스 설계 시, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
2. static변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. static메서드는 인스턴스 변수를 사용할 수 없다.
    - 반면에 인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

- 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야 하는 것이 있으면, static을 붙여준다.
- 작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않으면 static 붙일 것을 고려한다.

### 3. 오버로딩 (overloading)

한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '오버로딩'이라 한다.

#### 1. 오버로딩의 조건

1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.

오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로 **return 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.**

      void println()
      void println(boolean x)
      void println(char x)
      void println(char[] x)
      void println(double x)
      ... -> 오버로딩의 예시(매개변수 type이 달라도 됨)

#### 2. 가변인자(varargs)와 오버로딩

매개변수 개수를 동적으로 지정해줄 수 있다. (JDK1.5 부터) [type... varName]

      public PrintStream printf(String format, Object... args) { ... }
      -> 가변인자의 예시(type... varName)

만약 위와 같이 가변인자 외에 고정 매개변수가 더 있다면, 가변인자를 가장 마지막에 선언해야 한다. 아니면 컴파일 에러가 발생한다. 가변인자는 내부적으로 배열을 이용한다. 그래서 가변인자가 선언된 메서드를 호출할
때마다 배열이 새로 생성된다.  
그렇다면, 배열로 하는 것과 가변인자와는 어떤 차이가 있는가?  
배열인 경우에는 반드시 인자를 지정해 줘야하기 때문에, null이나 길이가 0인 배열로 꼭 지정해줘야 한다.

- [주의] 가능하면 가변인자를 사용하는 메서드는 오버로딩하지 않는 것이 좋다.

### 4. 생성자 (constructor)

#### 1. 생성자에서 다른 생성자 호출하기 - this

1. 생성자의 이름으로 클래스이름 대신 this를 사용한다.
2. 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다. -> CarTest2.java 참고

* this
    * 참조변수로 인스턴스 자신을 가리킨다.
    * this로 인스턴스변수에 접근 가능
    * this를 사용할 수 있는 것은 인스턴스멤버뿐이다.
        * static 메서드는 사용 불가. (static은 인스턴스 생성하지 않고도 호출될 수 있기 때문)

#### 2. 생성자를 이용한 인스턴스의 복사

인스턴스와 동일한 상태(모든 인스턴스 변수가 동일한 값 가지는 것)를 갖는 인스턴스를 하나 더 만들 때 생성자 이용!

```
Car(Car c) { // c 인스턴스의 인스턴스변수들을 인스턴스 자신으로 복사하는 것.
    color = c.color;
    gearType = c.gearType;
    door = c.door;
}
``` 

=> 복사하는 것이지, 서로 같은 인스턴스를 공유하는 것이 아니다. (별도의 인스턴스)  
따라서, 독립적인 메모리공간에 존재하여 값 변경해도 다른 인스턴스에 영향을 주지 않는다.

</div>
</details>

<details>
<summary>7. 객체지향 프로그래밍 Ⅱ 🤩</summary>
<div markdown="1">  

## 7. 객체지향 프로그래밍의 꽃

### 1. 상속 (inheritance)

1. Parent / 2. Child
2. Child는 Parent클래스의 멤버를 모두 상속받기 때문에, 자식이 부모보다 더 넓은 범위를 가진다.
    1. 자식 이기는 부모 없다..
    2. 생성자와 초기화 블럭은 상속되지 않음. 멤버만 상속!
    3. 접근제어자가 private 또는 default인 멤버들은 상속되지 않는다기보다 상속은 받지만 접근이 제한되는 것이다.
3. 그러한 이유인지, 'extends'를 사용함.

#### 1-1. 포함관계

상속이외에도 클래스를 재사용하는 '포함' 관계를 맺어주는 방법.  
한 클래스의 멤버변수로 다른 클래스 타입의 인스턴스를 선언하는 것을 뜻한다.

```java
//class Circle {
//    int x, y, r;
//}

class Point {
    int x, y;
}

class Circle {
    Point c = new Point();
    int r;
}
```

#### 상속과 포함 구분법

1. 상속관계: '~은 ~이다.'
2. 포함관계: '~은 ~을 가지고 있다.'

### 2. 오버라이딩 (overriding)

parent로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라 한다.

```java
class Point {
    int x, y;

    String getLocation() {
        return x + ", " + y;
    }
}

class Point3D extends Point {
    int z;

    @Override
    String getLocation() {
        return x + ", " + y + ", " + z;
    }
}
```

#### 오버라이딩 조건

메서드

1. 이름이 같아야 한다.
2. 매개변수가 같아야 한다.
3. 리턴타입이 같아야 한다.

다만, 접근제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

1. 접근제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
    * 만약 parent의 메서드가 protected라면, 오버라이딩하는 자식의 메서드는 protected 또는 public이어야 한다. (대부분 같은 접근 제어자 사용)
    * public > protected > default > private
2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

```java
import java.io.IOException;
import java.sql.SQLException;

class Parent {
    void parentMethod() throws IOException, SQLException {
        // ...
    }
}

class Child extends Parent {
    @Override
    void parentMethod() {
        // ...
    }
}
```

#### 1. super

자손클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다. 멤버변수와 지역변수의 이름이 같을 때 this로 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 통해 구별이
가능하다.  
조상과 자식이 중복될 때는 super를 쓰자.

```java
class Point {
    int x, y;

    String getLocation() {
        return x + ", " + y;
    }
}

class Point3D extends Point {
    int z;

    String getLocation() {
        return super.getLocation() + ", " + z;
    }
}
```

#### 2. super() - 조상 클래스의 생성자

this()와 마찬가지로 super() 역시 생성자이다. this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.
자손 클래스 인스턴스를 생성하면, 자손 멤버 + 조상 멤버로 하여 하나가 생성된다. 이때 조상 클래스 멤버 초기화가 되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다.  
조상 클래스 생성자의 호출은 최고 조상인 Object클래스의 생성자인 Object()까지 가야 끝이 난다.  
상속받은 클래스의 생성자 첫 줄에 조상의 생성자를 호출하지 않으면 컴파일러가 자동으로 super()를 호출할 것이다.


</div>
</details>