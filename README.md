# javaStandard

Java의 정석 3판 학습노트 정리

<details>
<summary>5. 배열 array</summary>
<div markdown="1">       

## 5. 배열 array

### 1. 배열의 복사

#### 1. for문

      1. 기존 배열 길이 2배
      2. 값 복사

#### 2. System.arraycopy()

      1. 지정된 범위 값들을 한 번에 통째로 복사
      2. 더욱 효율적

### 2. 배열의 활용

#### 1. 총합과 평균

#### 2. 최대값과 최소값

      1. 첫번째 요소로 최대, 최소를 초기화

#### 3. 섞기(shuffle)

      1. 카드섞기
      2. 로또번호 생성
        - 6개 뽑으므로, 인덱스를 0~5까지 반복하면서 임의의 위치에 있는 값과 자리를 바꾼다.
        - 뽑을 때는, 앞에서부터 6개를 뽑으면 된다.(인덱스 0~5)

### 2. String 배열

#### 1. 변경 불가한 객체 (immutable)

      1. '=='가 아닌 equals()로 내용 비교

### 3. 다차원 배열

#### 1. 2차원 배열 선언

      1. int[][] score;
      2. int score[];
      3. int[] score[];
      4. int[][] score = new int[4][3] // 4행 3열

#### 2. 2차원 배열 초기화

      1. int[][] score = new int[][] { {1,2,3}, {4,5,6} };
      2. int[][] score = { {1,2,3}, {4,5,6} }; // new int[][] 생략 가능
      3. int[][] score = {
                            {1,2,3},
                            {4,5,6}
                         };

#### 3. 좌표에 X표 하기

      1. 숫자 1에 문자 '0'을 더하면 문자 '1'이 된다.
      2. println이 1차원 배열을 바로 출력 가능한 경우는, char배열일 때만.

#### 4. 빙고

      1. 2중 반복문 탈출(break 이름 붙이기)
      2. **outer**:
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
                    ...
                    if () break **outer**; // 2중 반복문 탈출 이름붙이기
                }
            }

#### 5. 단어 맞추기

      1. equals()

</div>
</details>

<details>
<summary>6. 객체지향 프로그래밍 🤩</summary>
<div markdown="1">  

## 6. 객체지향 프로그래밍 (핵심)

### 1. 클래스와 객체

클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아니다. 클래스를 정의하고 객체를 생성할 때는 어떻게 정의할지 고민할 필요가 없다. 그냥 생성만 하면 된다.

#### 1. 객체와 인스턴스

클래스 -> 인스턴스(객체) : 클래스의 인스턴스화. 이때 이 객체를 그 클래스의 인스턴스라고 한다.

#### 2. 객체의 구성요소 - 속성과 기능

객체를 정의한 것이 클래스이므로, 클래스 안에는 객체의 모든 속성과 기능이 정의되어 있다.

- '속성'(property): **'멤버변수'** (member variable, field)
- '기능'(function): **'메서드'** (method)

      class Tv {
            // member
            String color;
            boolean power;
            int channel;

            // method
            void power() { power = !power; }
            void channelUp() { channel++; }
            void channelDown() { channel--; }
            }

#### 3. 인스턴스 생성과 사용

      Tv t = new Tv();
      t.channel = 7;
      t.channelDown();

#### 4. 객체 배열

      Tv[] tvArr = new Tv[3]; // 참조변수 배열 생성
      // 객체를 생성해서 배열의 각 요소에 저장
      for (int i = 0; i < tvArr.length; i++) {
        tvArr[i] = new Tv();
      }

그러면, 여러 종류의 객체를 하나의 배열에 저장하는 방법은 없을까?? -> '다형성 참고'

#### 5. 클래스의 또 다른 정의

객체지향언어에서는 변수와 함수를 하나의 클래스에 정의하여 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있게 했다. 그것이 바로 클래스이다. C에서는 문자열을 문자의 배열로 다루지만, Java에서는
String이라는 클래스로 문자열을 다룬다. 문자열을 클래스로 정의한 이유는 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서이다.

1. user-defined type  
   primitive type 외에 프로그래머가 관련된 변수들을 묶어 하나의 타입으로 새로 만드는 것을 user-defined type이라 한다. 자바에서는 클래스가 곧 사용자 정의 타입이다.

### 2. 변수와 메서드

#### 1. 변수 종류

- 지역변수
    - 멤버변수 제외한 모든 변수 (메서드, 생성자, 초기화 내부)
- 멤버변수
    - 클래스변수 (공유변수) static O
    - 인스턴스 변수 static X

1. 인스턴스 변수  
   인스턴스마다 고유한 상태를 유지해야 하는 경우
2. 클래스 변수  
   모든 인스턴스가 공통된 값을 유지해야 하는 경우. (해당 변수를 공유해서 사용)
3. 지역 변수  
   블럭 내에서만 사용 가능.

#### 2. 메서드를 사용하는 이유

1. 높은 재사용성 (reusability)  
   한 번 만들어 놓은 메소드는 계속 호출 가능하고, 다른 프로그램에서도 사용이 가능하다.
2. 중복 코드 제거  
   같은 문장이 여러 곳에 반복할 경우, 하나로 묶어 메서드로 만들면 한 문장으로 대체 가능하다. 또한, 변경사항이 발생했을 때도 수정할 부분이 줄어든다. 오류 가능성도 낮아진다.
3. 프로그램의 구조화  
   main메서드는 프로그램의 전체 흐름이 한눈에 들어올 정도로 단순하게 구조화하는 것이 좋다. 프로그램 설계 시 내용이 없는 메서드를 작업단위로 만들어 놓고, 하나씩 완성해가는 것도 좋은 방법이다.

      public static void main(Stirng args[]) { // 메인 메서드 예시
        int[] numArr = new int[10];
      
        initArr(numArr);
        printArr(numArr);
        sortArr(numArr);
        printArr(numArr);
      }

#### 3. JVM 메모리 구조

응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
1. Method Area  
프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스파일(*.class)을 분석하여 클래스 데이터를 이곳에 저장한다.
이때, 그 클래스의 클래스변수도 함께 생성된다.
2. Heap  
모든 인스턴스가 생성되는 공간.
3. Call Stack (또는 Execution stack)  
메서드 작업에 필요한 메모리 공간을 제공한다. 메서드가 작업을 마치면 할당된 메모리공간은 반환되면서 비워진다.
따라서, call stack을 조사해보면 메서드 간의 호출관계와 현재 수행중인 메서드가 어느 것인지 알 수 있다.
    - 메서드가 호출되면 필요한 만큼 메모리를 스택에 할당받는다.
    - 메서드 수행이 끝나면 메모리를 반환하고 스택에서 pop된다.
    - call stack의 가장 위(top)의 메소드가 현재 실행 중인 메서드이다.
    - 아래 메소드가 바로 위의 메서드를 호출한 메서드이다.

=> Ch06 > CallStackTest 참고

</div>
</details>
